<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Water Drop Survivor</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #FFF0F5;
      font-family: Arial, sans-serif;
      touch-action: none;
      user-select: none;
    }
    #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
    .hud-top { padding: 20px; display: flex; flex-direction: column; gap: 10px; }
    .bar-container { width: 200px; height: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 10px; border: 2px solid #fff; overflow: hidden; }
    .bar-fill { height: 100%; transition: width 0.2s; }
    #hp-bar .bar-fill { background: #FF69B4; width: 100%; }
    #exp-bar .bar-fill { background: #4ECDC4; width: 0%; }
    .stat-text { color: #FF69B4; font-weight: bold; text-shadow: 1px 1px 0 #fff; font-size: 14px; }
    #levelup-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 240, 245, 0.95); display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 20; }
    .modal-content { background: #fff; padding: 20px; border-radius: 20px; border: 4px solid #FF69B4; width: 80%; max-width: 400px; text-align: center; }
    h2 { color: #FF69B4; margin-top: 0; }
    .upgrade-card { background: #E6E6FA; margin: 10px 0; padding: 15px; border-radius: 15px; border: 2px solid #9370DB; cursor: pointer; transition: transform 0.1s; }
    .upgrade-card:active { transform: scale(0.95); }
    .upgrade-title { font-weight: bold; color: #9370DB; font-size: 18px; }
    .upgrade-desc { font-size: 12px; color: #555; }
    #gameover-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 30; color: white; }
    .btn { background: #FF69B4; color: white; border: none; padding: 15px 30px; font-size: 20px; border-radius: 50px; margin-top: 20px; font-weight: bold; cursor: pointer; }
    .btn:active { transform: translateY(2px); }
    .level-up-text { position: fixed; font-size: 60px; font-weight: bold; color: #FFD700; text-shadow: 4px 4px 0 #FF69B4, -3px -3px 0 #4ECDC4; pointer-events: none; z-index: 15; animation: levelUpFloat 1s ease-out forwards; }
    @keyframes levelUpFloat { 0% { opacity: 1; transform: scale(0.5) translateY(0); } 100% { opacity: 0; transform: scale(1.5) translateY(-100px); } }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <div id="ui-layer">
    <div class="hud-top">
      <div class="bar-container" id="hp-bar-container"><div class="bar-fill" id="hp-fill"></div></div>
      <div class="stat-text" id="hp-text">HP: 100/100</div>
      <div class="bar-container" id="exp-bar-container" style="border-color: #4ECDC4;"><div class="bar-fill" id="exp-fill"></div></div>
      <div class="stat-text" id="lvl-text" style="color: #4ECDC4;">LVL: 1</div>
      <div class="stat-text" id="score-text" style="color: #9370DB;">KILLS: 0</div>
    </div>
    <div id="joystick-zone"></div>
  </div>

  <div id="levelup-modal">
    <div class="modal-content">
      <h2>⭐ LEVEL UP! ⭐</h2>
      <div id="upgrade-list"></div>
    </div>
  </div>

  <div id="gameover-screen">
    <h1 style="color: #FF69B4; font-size: 40px;">GAME OVER</h1>
    <p id="final-score">Kills: 0 | Level: 1</p>
    <button class="btn" id="restart-btn">TRY AGAIN</button>
  </div>

  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">{"imports": {"three": "https://unpkg.com/three@0.176.0/build/three.module.js"}}</script>

  <script type="module">
    import * as THREE from 'three';

    const COLORS = { bg: 0xFFF0F5, player: 0x4ECDC4, enemySquare: 0xFF69B4, enemyTriangle: 0xFFD700, enemyRound: 0x9370DB, ground: 0x7CFC00, exp: 0x00FFFF };
    const GAME_CONFIG = { playerSpeedBase: 0.12, enemySpeedBase: 0.05, waveInterval: 300, expValue: 10, baseExpReq: 20 };
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(type) {
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      if (type === 'levelup') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.2);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
      }
    }

    let scene, camera, renderer, player, enemies = [], projectiles = [], expGems = [], particles = [];
    let lastTime = 0, frameCount = 0, isPaused = false, isGameOver = false, gameTime = 0, waveCount = 0;
    const joystick = { x: 0, y: 0, active: false };
    const playerStats = { lvl: 1, exp: 0, expReq: 20, hp: 100, maxHp: 100, kills: 0, strength: 1, damage: 1, atkSpeed: 1, walkSpeed: 25, armor: 0 };
    const weapons = { gun: { active: true, damage: 15, cooldown: 1000, lastShot: 0, range: 12 }, sword: { active: false, damage: 30 }, aura: { active: false, damage: 5 }, meteor: { active: false, damage: 60 } };

    class Player {
      constructor() {
        const geometry = new THREE.SphereGeometry(0.5, 16, 16);
        const material = new THREE.MeshToonMaterial({ color: COLORS.player });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.y = 0.5;
        scene.add(this.mesh);
        this.velocity = new THREE.Vector3(0, 0, 0);
      }
      update(dt) {
        if (joystick.active) {
          const speed = GAME_CONFIG.playerSpeedBase * (playerStats.walkSpeed / 25);
          this.mesh.position.x += joystick.x * speed;
          this.mesh.position.z += joystick.y * speed;
          const angle = Math.atan2(joystick.x, joystick.y);
          this.mesh.rotation.y = angle;
        }
        camera.position.x = this.mesh.position.x;
        camera.position.z = this.mesh.position.z + 20;
        camera.lookAt(this.mesh.position);
        this.mesh.position.x = Math.max(-95, Math.min(95, this.mesh.position.x));
        this.mesh.position.z = Math.max(-95, Math.min(95, this.mesh.position.z));
      }
      takeDamage(amount) {
        playerStats.hp -= amount;
        updateHUD();
        if (playerStats.hp <= 0) gameOver();
      }
    }

    class Enemy {
      constructor(type, x, z) {
        this.type = type;
        let geometry, color;
        if (type === 0) { geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8); color = COLORS.enemySquare; }
        else if (type === 1) { geometry = new THREE.ConeGeometry(0.5, 1, 8); color = COLORS.enemyTriangle; }
        else { geometry = new THREE.SphereGeometry(0.5, 12, 12); color = COLORS.enemyRound; }
        const material = new THREE.MeshToonMaterial({ color });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.5, z);
        scene.add(this.mesh);
        this.hp = type === 0 ? 150 : type === 1 ? 40 : 80;
        this.speed = type === 0 ? 0.03 : type === 1 ? 0.08 : 0.05;
        this.isDead = false;
      }
      update(dt, playerPos) {
        if (this.isDead) return;
        const dx = playerPos.x - this.mesh.position.x;
        const dz = playerPos.z - this.mesh.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        if (dist > 0.5) {
          this.mesh.position.x += (dx / dist) * this.speed;
          this.mesh.position.z += (dz / dist) * this.speed;
        }
        if (dist < 1.0) player.takeDamage(20);
      }
      takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) this.die();
      }
      die() {
        this.isDead = true;
        scene.remove(this.mesh);
        spawnExp(this.mesh.position.x, this.mesh.position.z);
        playerStats.kills++;
        playerStats.exp += 10;
        if (playerStats.exp >= playerStats.expReq) levelUp();
        updateHUD();
      }
    }

    class Projectile {
      constructor(x, z, targetPos) {
        const geometry = new THREE.SphereGeometry(0.2, 8, 8);
        const material = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.5, z);
        scene.add(this.mesh);
        const dx = targetPos.x - x;
        const dz = targetPos.z - z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        this.vx = (dx / dist) * 0.4;
        this.vz = (dz / dist) * 0.4;
        this.life = 60;
      }
      update() {
        this.mesh.position.x += this.vx;
        this.mesh.position.z += this.vz;
        this.life--;
        if (this.life <= 0) { scene.remove(this.mesh); return false; }
        for (let enemy of enemies) {
          if (!enemy.isDead) {
            const dx = this.mesh.position.x - enemy.mesh.position.x;
            const dz = this.mesh.position.z - enemy.mesh.position.z;
            if (dx*dx + dz*dz < 0.6) {
              let dmg = weapons.gun.damage * playerStats.damage * playerStats.strength;
              enemy.takeDamage(Math.floor(dmg));
              scene.remove(this.mesh);
              return false;
            }
          }
        }
        return true;
      }
    }

    class Particle {
      constructor(pos, color) {
        const geo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
        const mat = new THREE.MeshBasicMaterial({ color });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(pos);
        this.vel = new THREE.Vector3((Math.random() - 0.5) * 0.3, Math.random() * 0.3, (Math.random() - 0.5) * 0.3);
        scene.add(this.mesh);
        this.life = 30;
      }
      update() {
        this.life--;
        this.mesh.position.add(this.vel);
        this.vel.y -= 0.02;
        if (this.life <= 0) { scene.remove(this.mesh); return false; }
        return true;
      }
    }

    class ExpGem {
      constructor(x, z) {
        const geometry = new THREE.OctahedronGeometry(0.3, 0);
        const material = new THREE.MeshToonMaterial({ color: COLORS.exp });
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.set(x, 0.5, z);
        scene.add(this.mesh);
        this.active = true;
      }
      update(playerPos) {
        if (!this.active) return;
        this.mesh.rotation.y += 0.05;
        const dx = playerPos.x - this.mesh.position.x;
        const dz = playerPos.z - this.mesh.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        if (dist < 5) {
          this.mesh.position.x += (dx / dist) * 0.2;
          this.mesh.position.z += (dz / dist) * 0.2;
        }
        if (dist < 0.8) {
          scene.remove(this.mesh);
          this.active = false;
        }
      }
    }

    function spawnParticles(pos, color, count) {
      for(let i=0; i<count; i++) particles.push(new Particle(pos, color));
    }

    function spawnExp(x, z) {
      expGems.push(new ExpGem(x, z));
    }

    function spawnFountain() {
      const playerPos = player.mesh.position.clone();
      for(let i = 0; i < 30; i++) {
        const angle = (Math.PI * 2 * i) / 30;
        const speed = 0.4 + Math.random() * 0.3;
        const vel = new THREE.Vector3(Math.cos(angle) * speed, Math.random() * 0.8 + 0.7, Math.sin(angle) * speed);
        const particle = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshToonMaterial({ color: COLORS.player }));
        particle.position.copy(playerPos);
        particle.position.y += 1.5;
        scene.add(particle);
        particle.userData = { velocity: vel, life: 50, isFountain: true };
        particles.push(particle);
      }
      const text = document.createElement('div');
      text.className = 'level-up-text';
      text.innerText = '⭐ LEVEL UP! ⭐';
      text.style.left = (window.innerWidth/2 - 100) + 'px';
      text.style.top = (window.innerHeight/2 - 100) + 'px';
      document.body.appendChild(text);
      setTimeout(() => text.remove(), 1000);
    }

    function levelUp() {
      isPaused = true;
      playerStats.lvl++;
      playerStats.exp = 0;
      playerStats.expReq = playerStats.lvl * 20;
      playerStats.maxHp += 20;
      playerStats.hp = playerStats.maxHp;
      playSound('levelup');
      spawnFountain();
      showUpgradeModal();
    }

    function showUpgradeModal() {
      const modal = document.getElementById('levelup-modal');
      const list = document.getElementById('upgrade-list');
      list.innerHTML = '';
      const upgrades = [
        { title: 'STRENGTH', desc: 'Damage +10%', apply: () => { playerStats.strength += 0.1; } },
        { title: 'HASTE', desc: 'Atk Speed +10%', apply: () => { playerStats.atkSpeed += 0.1; } },
        { title: 'ARMOR', desc: 'Armor +10%', apply: () => { playerStats.armor += 10; } },
        { title: 'VITALITY', desc: 'HP +20', apply: () => { playerStats.maxHp += 20; playerStats.hp = playerStats.maxHp; } }
      ];
      upgrades.forEach((u, idx) => {
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        card.innerHTML = `<div class="upgrade-title">${u.title}</div><div class="upgrade-desc">${u.desc}</div>`;
        card.onclick = () => {
          u.apply();
          modal.style.display = 'none';
          isPaused = false;
          updateHUD();
        };
        list.appendChild(card);
        const colors = ['#000', '#FF0000', '#FFFF00', '#808080'];
        card.style.backgroundColor = colors[idx];
        card.style.color = '#FFF';
        card.querySelector('.upgrade-title').style.color = '#FFF';
      });
      modal.style.display = 'flex';
    }

    function updateHUD() {
      const hpPct = (playerStats.hp / playerStats.maxHp) * 100;
      document.getElementById('hp-fill').style.width = hpPct + '%';
      document.getElementById('hp-text').innerText = `HP: ${Math.ceil(playerStats.hp)}/${playerStats.maxHp}`;
      const expPct = (playerStats.exp / playerStats.expReq) * 100;
      document.getElementById('exp-fill').style.width = expPct + '%';
      document.getElementById('lvl-text').innerText = `LVL: ${playerStats.lvl}`;
      document.getElementById('score-text').innerText = `KILLS: ${playerStats.kills}`;
    }

    function gameOver() {
      isGameOver = true;
      isPaused = true;
      document.getElementById('gameover-screen').style.display = 'flex';
      document.getElementById('final-score').innerText = `Kills: ${playerStats.kills} | Level: ${playerStats.lvl}`;
    }

    function createWorld() {
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshToonMaterial({ color: COLORS.ground });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(COLORS.bg);
      scene.fog = new THREE.Fog(COLORS.bg, 20, 60);
      const aspect = window.innerWidth / window.innerHeight;
      const d = 20;
      camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
      camera.position.set(20, 20, 20);
      camera.lookAt(scene.position);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('game-container').appendChild(renderer.domElement);
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      createWorld();
      player = new Player();
      setupInputs();
      window.addEventListener('resize', onWindowResize, false);
      document.getElementById('restart-btn').addEventListener('click', () => location.reload());
      requestAnimationFrame(animate);
    }

    function spawnWave() {
      waveCount++;
      const count = 3 + Math.floor(waveCount / 2);
      for(let i=0; i<count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = 20 + Math.random() * 15;
        const ex = player.mesh.position.x + Math.cos(angle) * dist;
        const ez = player.mesh.position.z + Math.sin(angle) * dist;
        const type = Math.floor(Math.random() * 3);
        enemies.push(new Enemy(type, ex, ez));
      }
    }

    function setupInputs() {
      const zone = document.getElementById('joystick-zone');
      zone.addEventListener('touchstart', (e) => {
        const touch = e.changedTouches[0];
        joystick.active = true;
        joystick.originX = touch.clientX;
        joystick.originY = touch.clientY;
      }, { passive: false });
      zone.addEventListener('touchmove', (e) => {
        if (!joystick.active) return;
        const touch = e.changedTouches[0];
        const dx = touch.clientX - joystick.originX;
        const dy = touch.clientY - joystick.originY;
        const maxDist = 40;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > 0) {
          joystick.x = (dx / dist) * Math.min(dist, maxDist) / maxDist;
          joystick.y = (dy / dist) * Math.min(dist, maxDist) / maxDist;
        }
      }, { passive: false });
      zone.addEventListener('touchend', () => { joystick.active = false; joystick.x = 0; joystick.y = 0; });
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      const d = 20;
      camera.left = -d * aspect;
      camera.right = d * aspect;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate(time) {
      requestAnimationFrame(animate);
      const dt = (time - lastTime) / 1000 || 0;
      lastTime = time;
      gameTime += dt;
      if (isPaused || isGameOver) return;
      frameCount++;
      if (frameCount % GAME_CONFIG.waveInterval === 0) spawnWave();
      player.update(dt);
      enemies.forEach(e => e.update(dt, player.mesh.position));
      projectiles = projectiles.filter(p => p.update());
      expGems = expGems.filter(g => { g.update(player.mesh.position); return g.active; });
      particles = particles.filter(p => {
        if (p.userData && p.userData.isFountain) {
          p.userData.life--;
          p.mesh.position.add(p.userData.velocity);
          p.userData.velocity.y -= 0.05;
          if (p.userData.life <= 0) { scene.remove(p.mesh); return false; }
        } else {
          return p.update();
        }
        return true;
      });
      enemies = enemies.filter(e => !e.isDead);
      if (frameCount % 60 === 0 && weapons.gun.active && time - weapons.gun.lastShot > weapons.gun.cooldown) {
        let nearest = null, minDst = Infinity;
        for (let e of enemies) {
          if (!e.isDead) {
            const d = player.mesh.position.distanceTo(e.mesh.position);
            if (d < weapons.gun.range && d < minDst) { minDst = d; nearest = e; }
          }
        }
        if (nearest) {
          projectiles.push(new Projectile(player.mesh.position.x, player.mesh.position.z, nearest.mesh.position));
          weapons.gun.lastShot = time;
        }
      }
      updateHUD();
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>